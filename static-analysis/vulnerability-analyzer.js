const fs = require('fs');
const path = require("path");
const { parse, visit } = require('@solidity-parser/parser');

/**
 * Checks if a function node has proper access control.
 * @param {object} funcNode - The function definition AST node.
 * @returns {boolean} - True if access control is present, false otherwise.
 */
function hasAccessControl(funcNode) {
    let hasControl = false;
    // 1. Check for `onlyOwner` style modifiers
    if (funcNode.modifiers && funcNode.modifiers.length > 0) {
        for (const modifier of funcNode.modifiers) {
            if (modifier.name.toLowerCase().includes('owner') || modifier.name.toLowerCase().includes('auth')) {
                hasControl = true;
                break;
            }
        }
    }
    if (hasControl) return true;

    // 2. Check for `require(msg.sender == owner)` style checks
    visit(funcNode.body, {
        FunctionCall(callNode) {
            if (callNode.expression.type === 'Identifier' && callNode.expression.name === 'require') {
                const args = JSON.stringify(callNode.arguments);
                if (args.includes('msg.sender')) {
                    hasControl = true;
                }
            }
        }
    });
    return hasControl;
}


function analyze(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const ast = parse(content, { loc: true, tolerant: true });
    const lines = content.split('\n');

    const vulnerabilities = [];
    const stateVars = new Set();

    visit(ast, {
        StateVariableDeclaration(node) {
            for (const variable of node.variables) {
                stateVars.add(variable.name);
            }
        },
    });

    visit(ast, {
        FunctionDefinition(node) {
          const isPublicOrExternal =
            node.visibility === "public" || node.visibility === "external";
          if (!isPublicOrExternal || node.isConstructor) {
            return;
          }

          const functionName =
            node.name || (node.isReceive ? "receive" : "fallback");
          if (!functionName) return;

          const entryPoint = `Function: ${functionName} (Line: ${node.loc.start.line})`;

          // 1. Improper Access Control on HIGHLY SENSITIVE functions
          const highlySensitiveFunctions = [
            "withdraw",
            "selfdestruct",
            "destroy",
            "suicide",
            "transferownership",
            "setowner",
          ];
          if (
            highlySensitiveFunctions.includes(functionName.toLowerCase()) &&
            !hasAccessControl(node)
          ) {
            vulnerabilities.push({
              type: "Improper Access Control",
              entryPoint,
              severity: "Critical",
              description:
                "A highly sensitive function that can drain funds or change ownership is unprotected.",
              remediation:
                "Immediately apply a strong access control modifier like `onlyOwner`.",
              line: node.loc.start.line,
              vulnerableCode: lines[node.loc.start.line - 1].trim(),
            });
          }

          // 2. Reentrancy (State change AFTER external call)
          let externalCallLine = -1;
          let stateChangeAfterCall = false;
          if (node.body && node.body.statements) {
            // Find the last external call
            for (const statement of node.body.statements) {
              visit(statement, {
                FunctionCall(callNode) {
                  if (
                    callNode.expression.type === "MemberAccess" &&
                    ["call", "transfer", "send"].includes(
                      callNode.expression.memberName
                    )
                  ) {
                    externalCallLine = callNode.loc.start.line;
                  }
                },
              });
            }

            // If an external call exists, check for any state change after it
            if (externalCallLine !== -1) {
              for (const statement of node.body.statements) {
                if (statement.loc.start.line > externalCallLine) {
                  visit(statement, {
                    BinaryOperation(opNode) {
                      if (
                        opNode.operator === "=" &&
                        opNode.left.type === "Identifier" &&
                        stateVars.has(opNode.left.name)
                      ) {
                        stateChangeAfterCall = true;
                      }
                    },
                  });
                }
              }
            }
          }

          if (stateChangeAfterCall) {
            vulnerabilities.push({
              type: "Reentrancy",
              entryPoint,
              severity: "High",
              description:
                "A state variable is updated after an external call. This violates the Checks-Effects-Interactions pattern and can be exploited.",
              remediation:
                "Perform all state changes *before* making external calls to other contracts.",
              line: externalCallLine,
              vulnerableCode: lines[externalCallLine - 1].trim(),
            });
          }
        }
    });

    // Deduplicate vulnerabilities
    const uniqueVulnerabilities = vulnerabilities.filter(
        (vuln, index, self) => index === self.findIndex(v => v.type === vuln.type && v.line === vuln.line)
    );

    return uniqueVulnerabilities;
}

function main() {
    const filesToAnalyze = process.argv.slice(2);

    if (filesToAnalyze.length === 0) {
      console.log(`
Usage: node ${path.basename(__filename)} <file1.sol> [file2.sol] ...

Example:
  node ${path.basename(
    __filename
  )} contracts/SC01_ImproperAccessControl_Vulnerable.sol
  node ${path.basename(__filename)} contracts/*_Fixed.sol
`);
      return;
    }

    console.log('--- Static Analysis Report (vulnerability-analyzer.js) ---');
    filesToAnalyze.forEach((filePath) => {
      if (fs.existsSync(filePath)) {
        const findings = analyze(filePath);
        console.log(
          `\n\n================================================================`
        );
        console.log(`ðŸ“„ FILE: ${filePath}`);
        console.log(
          `================================================================`
        );
        if (findings.length > 0) {
          console.log(`\n     ðŸš¨ VULNERABILITIES FOUND:`);
          findings.forEach((vuln) => {
            console.log(`\n       ...................................`);
            console.log(`       - Type:        ${vuln.type}`);
            console.log(`       - Severity:    ${vuln.severity}`);
            console.log(`       - Location:    Line ${vuln.line}`);
            console.log(`       - Entry Point: ${vuln.entryPoint}`);
            console.log(`       - Code:        \`${vuln.vulnerableCode}\``);
            console.log(`       - Description: ${vuln.description}`);
            console.log(`       - Suggestion:  ${vuln.remediation}`);
          });
        } else {
          console.log(
            `\n     âœ… No obvious vulnerabilities found in ${filePath}`
          );
        }
      } else {
        console.log(`\n[!] File not found: ${filePath}`);
      }
    });
    console.log('\n\n--- End of Report ---');
}

main();
