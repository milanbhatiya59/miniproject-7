const fs = require('fs');
const { parse, visit } = require('@solidity-parser/parser');

function analyze(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const ast = parse(content, { loc: true });
    const lines = content.split('\n');

    const vulnerabilities = [];
    const stateVars = new Set();

    visit(ast, {
        StateVariableDeclaration(node) {
            for (const variable of node.variables) {
                stateVars.add(variable.name);
            }
        },
    });

    visit(ast, {
        FunctionDefinition(node) {
            const isPublicOrExternal = node.visibility === 'public' || node.visibility === 'external';
            if (!isPublicOrExternal) {
                return;
            }

            const functionName = node.name || (node.isReceive ? 'receive' : 'fallback');
            if (!functionName) return;

            const entryPoint = `Function: ${functionName} (Line: ${node.loc.start.line})`;

            // 1. Improper Access Control
            const sensitiveFunctions = ['withdraw', 'destroy', 'suicide', 'selfdestruct', 'setOwner', 'transferOwnership'];
            if (sensitiveFunctions.includes(functionName)) {
                let hasAccessControl = false;
                visit(node.body, {
                    ModifierInvocation(modifierNode) {
                        if (modifierNode.name === 'onlyOwner') {
                            hasAccessControl = true;
                        }
                    },
                    FunctionCall(callNode) {
                        if (callNode.expression.type === 'Identifier' && callNode.expression.name === 'require') {
                            if (JSON.stringify(callNode.arguments).includes('msg.sender')) {
                                hasAccessControl = true;
                            }
                        }
                    }
                });

                if (!hasAccessControl) {
                    vulnerabilities.push({
                        type: 'Improper Access Control',
                        entryPoint,
                        severity: 'High',
                        description: 'A critical function is exposed to the public without any access restrictions, allowing any user to execute it and potentially drain funds, change ownership, or destroy the contract.',
                        remediation: 'Apply a modifier like `onlyOwner` or add a `require(msg.sender == owner)` check to ensure only authorized accounts can call this function.',
                        line: node.loc.start.line,
                        vulnerableCode: lines[node.loc.start.line - 1].trim()
                    });
                }
            }

            // 2. Reentrancy (Checks for state change after external call)
            let externalCallNode = null;
            let stateChangeAfterCall = false;
            if (node.body && node.body.statements) {
                for (const statement of node.body.statements) {
                    // Find external calls
                    if (statement.type === 'ExpressionStatement' && statement.expression.type === 'FunctionCall') {
                        const call = statement.expression;
                        if (call.expression.type === 'MemberAccess' && ['call', 'transfer', 'send'].includes(call.expression.memberName)) {
                            externalCallNode = statement;
                        }
                    }

                    // If an external call has been found, check for subsequent state changes
                    if (externalCallNode) {
                        if (statement.type === 'ExpressionStatement' && statement.expression.type === 'BinaryOperation' && statement.expression.operator === '=') {
                            if (statement.expression.left.type === 'Identifier' && stateVars.has(statement.expression.left.name)) {
                                stateChangeAfterCall = true;
                            }
                        }
                    }
                }
            }

            if (externalCallNode && stateChangeAfterCall) {
                vulnerabilities.push({
                    type: 'Reentrancy',
                    entryPoint,
                    severity: 'High',
                    description: 'A state variable is updated after an external call. An attacker could re-enter the function before the state is updated, leading to multiple withdrawals or other exploits.',
                    remediation: 'Follow the Checks-Effects-Interactions pattern. Perform all state changes *before* making external calls.',
                    line: externalCallNode.loc.start.line,
                    vulnerableCode: lines[externalCallNode.loc.start.line - 1].trim()
                });
            }

            // 3. Integer Overflow/Underflow
            visit(node.body, {
                BinaryOperation(opNode) {
                    if (['+', '-', '*', '/'].includes(opNode.operator)) {
                         // This is a naive check. Solidity 0.8+ has built-in protection.
                         // A better check would look for assembly blocks or older compiler versions.
                         // For SC08, the vulnerability is the logic itself.
                         if (functionName === 'increment' || functionName === 'decrement') {
                             vulnerabilities.push({
                                 type: 'Integer Overflow/Underflow',
                                 entryPoint,
                                 severity: 'Medium',
                                 description: `A mathematical operation on a state variable is performed without checks for overflow or underflow. This could allow an attacker to wrap the integer value (e.g., from 255 to 0) and corrupt contract logic.`,
                                 remediation: 'Use a safe math library (like OpenZeppelin\'s SafeMath) for arithmetic operations, or use Solidity version 0.8.0+ which has built-in checks.',
                                 line: opNode.loc.start.line,
                                 vulnerableCode: lines[opNode.loc.start.line - 1].trim()
                             });
                         }
                    }
                }
            });

            // 4. Insecure Randomness
            visit(node.body, {
                MemberAccess(memberAccessNode) {
                    if (memberAccessNode.expression.type === 'Identifier' && memberAccessNode.expression.name === 'block' && ['timestamp', 'difficulty', 'number'].includes(memberAccessNode.memberName)) {
                        vulnerabilities.push({
                            type: 'Insecure Randomness',
                            entryPoint,
                            severity: 'Medium',
                            description: `The contract uses a predictable blockchain variable (e.g., block.timestamp, block.number) to generate randomness. Miners can manipulate these values to their advantage.`,
                            remediation: 'Use a commit-reveal scheme or a verifiable random function (VRF) from an oracle service like Chainlink to generate secure random numbers.',
                            line: memberAccessNode.loc.start.line,
                            vulnerableCode: lines[memberAccessNode.loc.start.line - 1].trim()
                        });
                    }
                }
            });
        }
    });

    // Deduplicate vulnerabilities
    const uniqueVulnerabilities = vulnerabilities.filter(
        (vuln, index, self) => index === self.findIndex(v => v.type === vuln.type && v.line === vuln.line)
    );

    return uniqueVulnerabilities;
}

function main() {
    const vulnerableFiles = [
        'contracts/SC01_ImproperAccessControl_Vulnerable.sol',
        'contracts/SC04_LackOfInputValidation_Vulnerable.sol',
        'contracts/SC05_Reentrancy_Vulnerable.sol',
        'contracts/SC08_IntegerOverflowAndUnderflow_Vulnerable.sol',
        'contracts/SC09_InsecureRandomness_Vulnerable.sol',
        'contracts/SC10_DoS_Vulnerable.sol'
    ];

    console.log('--- Static Analysis Report (vulnerability-analyzer.js) ---');
    vulnerableFiles.forEach(filePath => {
        if (fs.existsSync(filePath)) {
            const findings = analyze(filePath);
            if (findings.length > 0) {
                console.log(`\n[+] Vulnerabilities found in ${filePath}:`);
                findings.forEach(vuln => {
                    console.log(`\n  --------------------------------------`);
                    console.log(`  - Type: ${vuln.type}`);
                    console.log(`  - Severity: ${vuln.severity}`);
                    console.log(`  - Location: Line ${vuln.line}`);
                    console.log(`  - Entry Point: ${vuln.entryPoint}`);
                    console.log(`  - Vulnerable Code: \`${vuln.vulnerableCode}\``);
                    console.log(`  - Description: ${vuln.description}`);
                    console.log(`  - Remediation: ${vuln.remediation}`);
                });
            } else {
                console.log(`\n[-] No obvious vulnerabilities found in ${filePath}`);
            }
        } else {
            console.log(`\n[!] File not found: ${filePath}`);
        }
    });
    console.log('\n\n--- End of Report ---');
}

main();
